---
title: "Measuring covid measures"
author: "Tisja Smits"
output: 
    flexdashboard::flex_dashboard:
        storyboard: true
        theme: journal # default / cosmo / bootstrap / cerulean / journal! / flatly! / readable / spacelab / united / lumen / paper / sandstone / simplex! / yeti!
---

```{r package and theme setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)

library(tidyverse)
library(spotifyr)
library(compmus)

library(flexdashboard)
library(plotly)
library(gridExtra)

library(tidymodels)
library(ggdendro)
library(heatmaply)

theme_mine <-
  theme_minimal() +
  theme(
    text = element_text(family = "Rubik", size = 12),
    legend.title = element_blank(),
    strip.text = element_text(color = "black"),
    strip.background = element_rect(fill = "gray90", color = NA),
    panel.border = element_rect(fill = NA, color = "gray80"),
    axis.ticks = element_line(color = "gray80")
    )
```

```{r toptracks setup}
NL2020 <- get_playlist_audio_features("", "37i9dQZF1DWU7JsJYlV18s") %>% 
  mutate(playlist = "NL 2020", year = "2020", category = "NL Top Tracks")
my2020 <- get_playlist_audio_features("", "37i9dQZF1ELZX0wn2u2RJw") %>% 
  mutate(playlist = "My 2020", year = "2020", category = "My Top Tracks")
NL2019 <- get_playlist_audio_features("", "37i9dQZF1DX24O9ZrSq8yt") %>% 
  mutate(playlist = "NL 2019", year = "2019", category = "NL Top Tracks")
my2019 <- get_playlist_audio_features("", "37i9dQZF1Etf5utVpuKPi7")  %>% 
  mutate(playlist = "My 2019", year = "2019", category = "My Top Tracks")

toptracks <-
  bind_rows(NL2020, my2020, NL2019, my2019)

toptracks50 <-
  bind_rows(NL2020, my2020[1:50,], NL2019, my2019[1:50,])

toptracks_stats <- toptracks %>% 
  group_by(playlist) %>%
  summarise(
    valence_sd = sd(valence),
    valence = mean(valence),
    energy_sd = sd(energy),
    energy = mean(energy),
    tempo_sd = sd(tempo),
    tempo = mean(tempo),
    danceability_sd = sd(danceability),
    danceability = mean(danceability),
    loudness_sd = sd(loudness),
    loudness = mean(loudness),
    track.name = NA,     # or "average"
    key = median(key),
    mode = mean(mode),
    mode_name = NA
    )
toptracks_stats["category"] <- c(
  "My Top Tracks","My Top Tracks",
  "NL Top Tracks","NL Top Tracks")
toptracks_stats["year"] <- c(
  "2019","2020",
  "2019","2020")
```



<!-- volgorde nog aanpassen -->


<!-- NIEUWE CONTENT -->

### The final judgment: classification

```{r classifier setup}
get_conf_mat <- function(fit) {
  outcome <- .get_tune_outcome_names(fit)
  fit %>% 
    collect_predictions() %>% 
    conf_mat(truth = outcome, estimate = .pred_class)
}  

get_pr <- function(fit) {
  fit %>% 
    conf_mat_resampled() %>% 
    group_by(Prediction) %>% mutate(precision = Freq / sum(Freq)) %>% 
    group_by(Truth) %>% mutate(recall = Freq / sum(Freq)) %>% 
    ungroup() %>% filter(Prediction == Truth) %>% 
    select(class = Prediction, precision, recall)
}

toptracks_features <-
  toptracks50 %>%
  add_audio_analysis() %>% 
  mutate(
    playlist = factor(playlist),
    segments = map2(segments, key, compmus_c_transpose),
    pitches =
      map(
        segments,
        compmus_summarise, pitches,
        method = "mean", norm = "manhattan"
      ),
    timbre =
      map(
        segments,
        compmus_summarise, timbre,
        method = "mean",
      )
  ) %>%
  mutate(pitches = map(pitches, compmus_normalise, "clr")) %>%
  mutate_at(vars(pitches, timbre), map, bind_rows) %>%
  unnest(cols = c(pitches, timbre))

toptracks_recipe_all <-
  recipe(
    playlist ~
      danceability +
      energy +
      loudness +
      speechiness +
      acousticness +
      instrumentalness +
      liveness +
      valence +
      tempo +
      duration +
      C + `C#|Db` + D + `D#|Eb` +
      E + `F` + `F#|Gb` + G +
      `G#|Ab` + A + `A#|Bb` + B +
      c01 + c02 + c03 + c04 + c05 + c06 +
      c07 + c08 + c09 + c10 + c11 + c12,
    data = toptracks_features,
  ) %>%
  step_center(all_predictors()) %>%
  step_scale(all_predictors())      # Converts to z-scores.

toptracks_recipe_top <-
  recipe(
    playlist ~
      tempo + A + 
      c02 + c03 + c05 + c06 + c07 + c08 + c09 + c10 + c11 + c12,
    data = toptracks_features,
  ) %>%
  step_center(all_predictors()) %>%
  step_scale(all_predictors())      # Converts to z-scores.

toptracks_cv <- toptracks_features %>% vfold_cv(5)
```

**k-nearest neighbor**
```{r k-Nearest Neighbor}
knn_model <-
  nearest_neighbor(neighbors = 1) %>%
  set_mode("classification") %>% 
  set_engine("kknn")
toptracks_knn <- 
  workflow() %>% 
  add_recipe(toptracks_recipe_all) %>% 
  add_model(knn_model) %>% 
  fit_resamples(
    toptracks_cv, 
    control = control_resamples(save_pred = TRUE)
  )
# toptracks_knn %>% get_conf_mat() %>% autoplot(type = "mosaic")
toptracks_knn %>% get_conf_mat() %>% 
  autoplot(type = "heatmap") + 
  labs(title = "Confusion matrix for all features") +
  scale_fill_viridis_c(limits = c(2, 30), direction = -1, guide = "none", option = "inferno")
knitr::kable(toptracks_knn %>% get_pr())
```

**Random forest**
```{r random forest}
forest_model <-
  rand_forest() %>%
  set_mode("classification") %>% 
  set_engine("ranger", importance = "impurity")

toptracks_forest <- 
  workflow() %>% 
  add_recipe(toptracks_recipe_all) %>% 
  add_model(forest_model) %>% 
  fit_resamples(
    toptracks_cv, 
    control = control_resamples(save_pred = TRUE)
  )
toptracks_forest_top <- 
  workflow() %>% 
  add_recipe(toptracks_recipe_top) %>% 
  add_model(forest_model) %>% 
  fit_resamples(
    toptracks_cv, 
    control = control_resamples(save_pred = TRUE)
  )

# toptracks_forest %>% get_conf_mat() %>% autoplot(type = "mosaic")
toptracks_forest %>% get_conf_mat() %>% 
  autoplot(type = "heatmap") + 
  labs(title = "Confusion matrix for all features") +
  scale_fill_viridis_c(limits = c(2, 30), direction = -1, guide = "none", option = "inferno")
knitr::kable(toptracks_forest %>% get_pr())

toptracks_forest_top %>% get_conf_mat() %>% 
  autoplot(type = "heatmap") + 
  labs(title = "Confusion matrix for the top features") +
  scale_fill_viridis_c(limits = c(2, 30), direction = -1, guide = "none", option = "inferno")
knitr::kable(toptracks_forest_top %>% get_pr())

workflow() %>% 
  add_recipe(toptracks_recipe_all) %>% 
  add_model(forest_model) %>% 
  fit(toptracks_features) %>% 
  pluck("fit", "fit", "fit") %>%
  ranger::importance() %>% 
  enframe() %>% 
  mutate(name = fct_reorder(name, value)) %>% 
  ggplot(aes(name, value, fill = value)) + 
  scale_fill_viridis_c(limits = c(1.5, 5.5), guide = "none", option = "inferno") +
  geom_col() + 
  coord_flip() +
  theme_minimal() +
  labs(title = "Importance of features for a random forest classifier", x = NULL, y = "Importance") +
  theme(panel.grid.minor.x = element_blank())
```

***

As can be seen in the top confusion matrix, the k-nearest neighbor classifier performs badly. However disappointing, this result is not surprising. Just as we have seen no big differences between the four playlists overall, it makes sense that nearest neighbors might not be from the 'correct' playlist.

The random forest classifiers perform much better. However, they are still not satisfactory and their results might even be considered insignificant. The second random forest classifier seems to perform somewhat better than the first. The second only considers the following features: tempo, A, and all timbre features except c01 and c04. The last plot shows that these selected features indeed are more important than others.


<!-- volgorde nog aanpassen -->



### Just an average girl?

The corpus I am going to analyze consists of four playlists: **my Top Tracks of 2019**, **my Top Tracks of 2020**, the **Top Tracks NL of 2019** and the **Top Tracks NL of 2020**. These playlists are respectively representative of the following groups I will be comparing: my taste in music in 2019, my taste in music in 2020, the average Dutch taste in music in 2019, and the average Dutch taste in music in 2020.
In this portfolio, I want to find an answer to the following questions:

##### 1. How did my taste in music in 2020 differ from 2019? (comparison between group 1 and 2)

##### 2. How did the average Dutch taste in music in 2020 differ from 2019? (comparison between group 3 and 4)

##### 3. How average was my taste in music in 2019? (comparison between group 1 and 3)

##### 4. How average was my taste in music in 2020? (comparison between group 2 and 4)

I find it very interesting to analyze these comparisons, especially in light of the coronavirus pandemic. Due to the **social distancing measures** I did not listen to music in any social setting, such as hanging out with friends, clubbing, or even working out at the gym. My hypothesis is that my taste in music was therefore *less* average in 2020 than it was in 2019.

Evidently, my corpus is representative for the groups I want to compare, because it actually consists of those groups. However, I do have to remark that a Top Tracks NL playlist might not be representative of 'the average'. It just contains those tracks that were listened to most often, possibly only within a certain demographic. Whether I belong to this demographic, I cannot say; there seems no information to be found about this anywhere on the internet.

My personal Top Tracks playlists also need a sidenote or two. First, I do not have a **premium Spotify account**, which means I get a limited amount of skips per hour and most playlists can only be played on shuffle. It might be that a song ended up a Top Track because it was in a playlist I listened to a lot, not because I liked that song so much. However, these limitations only apply when listening to Spotify on my phone. The desktop version of Spotify *does* allow for infinite skips and the freedom to choose songs manually, put songs in the waiting list, and play a playlist on shuffle or in order. 

Moreover, Spotify might be biasing playlists by including certain --possibly sponsored-- songs. Also, shuffle might not be completely random, playing **popular or sponsored songs** first. This way, I would be exposed to more popular songs, which might influence my Top Tracks, possibly making it more average.

A great example is **"Stuck with U" by Ariana Grande and Justin Bieber**. It is one of my Top Tracks of 2020. It used to be in a lot of different playlists I listened to at the time. And yes, I liked that song, but nevertheless, I am fairly sure there were other songs I liked more in 2020. I definitely consider this song atypical for the group 'my taste in music in 2020'.

A song I consider very typical for my taste in music in 2019 is **"Drive and Disconnect" by Nao**. I remember listening to this song on repeat when I discovered it, but also for a longer time after that. And even a few months later I rediscovered this song, and fell in lover all over again. Even now, it is still one of my favorite songs.

While browsing the API Reference, I found the following variables that seem interesting to analyze: genres, artists, popularity, danceability, energy, valence, speechiness, instrumentalness, key, mode, tempo.

<!-- Feedback: How many songs are in each of the playlists? -->




### (No) time to relax

#### An energy-valence scatter plot

```{r mood plot}
ggplotly(ggplot(toptracks50,
       aes(
         x = valence,
         y = energy,
         color = year,
         label = track.name
       )
      ) +
  geom_point(alpha = 0.4) +
  geom_segment(
    data = toptracks_stats, 
    aes(
      x = valence, 
      y = energy-energy_sd, 
      xend = valence, 
      yend = energy+energy_sd,
      alpha = 0.8
      )
    ) +
  geom_segment(
    data = toptracks_stats, 
    aes(
      x = valence-valence_sd, 
      y = energy, 
      xend = valence+valence_sd, 
      yend = energy,
      alpha = 0.8
      )
    ) +
  geom_point(
    data = toptracks_stats,
    shape = 15,
    size = 3,
    alpha = 0.8
    ) +
    
  scale_x_continuous(breaks=seq(0,1,0.25)) +
  scale_y_continuous(breaks=seq(0,1,0.25)) +
  facet_wrap(~category) +
  labs(
    x = "Valence",
    y = "Energy"
  ) +
  theme_mine
)
```

```{r mood plot densities, include=FALSE}
# Playlists
grid.arrange(
  ggplot(
    toptracks50,
    aes(x = valence,
        color = playlist,
        fill = playlist)) +
    geom_density(alpha = 0.3) +
    facet_grid(.~year) +
    theme_light() +
    theme(axis.title.x = element_blank(), legend.position = "none"),
  
  ggplot() + theme(panel.background = element_blank()),
  
  ggplot(toptracks50,
         aes(
           x = valence,
           y = energy,
           color = playlist,
           label = track.name
         )
        ) +
    geom_point(alpha = 0.5, show.legend = FALSE) +
    facet_grid(category~year) +
    theme_light() +
    theme(legend.position = "none"),
  
  ggplot(
    toptracks50,
    aes(x = energy,
        color = playlist,
        fill = playlist)) +
    geom_density(alpha = 0.3) +
    facet_grid(category~.) +
    coord_flip() +
    theme_light() +
    theme(axis.title.y = element_blank()),
  
  ncol=2, nrow=2, widths=4:3, heights=1:2
)

# Categories
grid.arrange(
  ggplot(
    toptracks50,
    aes(x = valence,
        color = category,
        fill = category)) +
    geom_density(alpha = 0.3) +
    theme_light() +
    theme(axis.title.x = element_blank(), legend.position = "none"),
  
  ggplot() + theme(panel.background = element_blank()),
  
  ggplot(
    toptracks50,
    aes(
      x = valence,
      y = energy,
      color = category,
      label = track.name
    )
  ) +
    geom_point(alpha = 0.5, show.legend = FALSE) +
    theme_light(),
  
  ggplot(
    toptracks50,
    aes(x = energy,
        color = category,
        fill = category)) +
    geom_density(alpha = 0.3) +
    coord_flip() +
    theme_light() +
    theme(axis.title.y = element_blank()),
  
  ncol=2, nrow=2, widths=4:3, heights=1:2
)

# Years
grid.arrange(
  ggplot(
    toptracks50,
    aes(x = valence,
        color = year,
        fill = year)) +
    geom_density(alpha = 0.3) +
    theme_light() +
    theme(axis.title.x = element_blank(), legend.position = "none"),
  
  ggplot() + theme(panel.background = element_blank()),
  
  ggplot(
    toptracks50,
    aes(
      x = valence,
      y = energy,
      color = year,
      label = track.name
    )
  ) +
    geom_point(alpha = 0.5, show.legend = FALSE) +
    theme_light(),
  
  ggplot(
    toptracks50,
    aes(x = energy,
        color = year,
        fill = year)) +
    geom_density(alpha = 0.3) +
    coord_flip() +
    theme_light() +
    theme(axis.title.y = element_blank()),
  
  ncol=2, nrow=2, widths=4:3, heights=1:2
)
```

```{r mood plot 2d density, include=FALSE}
ggplot(toptracks50,
       aes(
         x = valence,
         y = energy,
         label = track.name
       )
) +
  stat_density_2d(
    geom = "polygon", 
    aes(alpha = ..level.., fill = playlist),
    bins = 5,
    show.legend = FALSE) +
  geom_point(
    aes(color = playlist), 
    show.legend = FALSE) +
  facet_grid(category~year) +
  theme_light()


ggplot(toptracks50,
       aes(
         x = valence,
         y = energy,
         # color = playlist,
         label = track.name
       )
) +
  geom_point(
    aes(color = playlist, alpha = 0.3), 
    show.legend = FALSE) +
  stat_density_2d(
    aes(color = playlist),
    bins = 4
    ) +
  facet_grid(category~year) +
  theme_light()


ggplot(toptracks50,
       aes(
         x = valence,
         y = energy,
         color = playlist,
         label = track.name
       )
) +
  geom_point(
    aes(alpha = 0.3), 
    show.legend = FALSE) +
  stat_ellipse(
    type = "t",
    linetype = 3) +
  facet_grid(category~year) +
  theme_light()
```

***
<!-- Typical My 2020: ... -->
<!-- Typical NL 2020: ... -->
<!-- Typical because in the middle of the plot () -->


### (No) time to dance
```{r dance plot}
ggplotly(ggplot(toptracks50,
       aes(
         x = tempo,
         y = danceability,
         color = year,
         label = track.name
       )
      ) +
  geom_point(alpha = 0.4) +
  geom_segment(
    data = toptracks_stats, 
    aes(
      x = tempo, 
      y = danceability-danceability_sd, 
      xend = tempo, 
      yend = danceability+danceability_sd,
      alpha = 0.8
      )
    ) +
  geom_segment(
    data = toptracks_stats, 
    aes(
      x = tempo-tempo_sd, 
      y = danceability, 
      xend = tempo+tempo_sd, 
      yend = danceability,
      alpha = 0.8
      )
    ) +
  geom_point(
    data = toptracks_stats,
    shape = 15,
    size = 3,
    alpha = 0.8
    ) +
  
  scale_x_continuous(breaks=seq(20,220,40)) +
  scale_y_continuous(breaks=seq(0.1,1,0.2)) +
  
  facet_wrap(~category) +
  labs(
    x = "Tempo (bpm)",
    y = "Danceability"
  ) +
  theme_mine
)
```

***
#### A danceability-tempo scatter plot
<!-- Typical My 2020: Cash -->
<!-- Typical NL 2020: Loop Niet Weg -->
<!-- Typical because in the middle of the danceability-tempo plot (tempo = 100 bpm, danceability = 0.67) -->
<!-- AND both in top 20 of playlist -->



### Observations

#### Valence versus Energy

```{r valence density}
ggplotly(ggplot(
  toptracks,
  aes(x = valence,
      color = playlist,
      fill = playlist)) +
  geom_density(alpha = 0.3) +
  geom_vline(aes(xintercept = mean(valence)), 
             alpha = 0.5) +
  geom_vline(data = toptracks_stats, 
             aes(xintercept = valence, color = playlist),
             linetype = "dashed") +
  
  geom_text(data = toptracks_stats,
    aes(x = valence+0.09,
        y = 0.5,
        label = "mean")
  ) +
  
  facet_grid(category~year) +
  
  labs(x = "Valence", y = "Density") +
  theme_mine +
  theme(
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    panel.grid.major.y = element_blank(),
    panel.grid.minor.y = element_blank(),
    panel.border = element_blank(),
    legend.position = "none"
  )
)
```

- Valence in Top Tracks NL 2019 is very nicely and equally distributed, unlike Top Tracks NL 2020. In fact, Top Tracks NL 2020 seems to have the inverted valence distribution of my Top Tracks playlists.

```{r energy density}
ggplotly(ggplot(
  toptracks,
  aes(x = energy,
      color = playlist,
      fill = playlist)) +
  geom_density(alpha = 0.3) +
  geom_vline(aes(xintercept = mean(energy)), 
             alpha = 0.5) +
  geom_vline(data = toptracks_stats, 
             aes(xintercept = energy, color = playlist),
             linetype = "dashed") +
  
  geom_text(data = toptracks_stats,
    aes(x = 0.73,
        y = 0.7,
        label = "mean")
  ) +
  facet_grid(category~year) +
  
  labs(x = "Energy", y = "Density") +
  theme_mine +
  theme(
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    panel.grid.major.y = element_blank(),
    panel.grid.minor.y = element_blank(),
    panel.border = element_blank(),
    legend.position = "none"
  )
)
```

- Energy: In both categories of 2019, there is a bump around 0.7. They also spread out downward quite equally. The NL Top Tracks of 2020 seems to be the odd one out (again); energy was quite *lower* on average and more spread out. The mode, however, was somewhat *higher* than the bumps of the other playlists.

#### Tempo versus Danceability

```{r tempo density}
ggplotly(ggplot(
  toptracks,
  aes(x = tempo,
      color = playlist,
      fill = playlist)) +
  geom_density(alpha = 0.3) +
  geom_vline(aes(xintercept = mean(tempo)), 
             alpha = 0.5) +
  geom_vline(data = toptracks_stats, 
             aes(xintercept = tempo, color = playlist),
             linetype = "dashed") +
    
  geom_text(data = toptracks_stats,
    aes(x = 130,
        y = 0.022,
        label = "mean")
  ) +
    
  scale_x_continuous(breaks=seq(20,220,40)) +
  facet_grid(category~year) +
    
  labs(x = "Tempo (bpm)", y = "Density") +
  theme_mine +
  theme(
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    panel.grid.major.y = element_blank(),
    panel.grid.minor.y = element_blank(),
    panel.border = element_blank(),
    legend.position = "none"
  )
)
```

- The tempo distribution in 2019 was pretty much the same in both categories, both peaking at 100 bpm. The peak tempo of My Top Tracks of 2020 has shifted upwards to 105 bpm. The NL Top Tracks of 2020 is totally different form the rest, with no real peaks, and more spread out to lower (90) and higher (120) bpm's. The reference lines for the means clearly show that there was a decrease in tempo between the NL Top Tracks of 2019 and 2020.

```{r danceability density}
ggplotly(ggplot(
  toptracks,
  aes(x = danceability,
      color = playlist,
      fill = playlist)) +
  geom_density(alpha = 0.3) +
  geom_vline(aes(xintercept = mean(danceability)), 
             alpha = 0.5) +
  geom_vline(data = toptracks_stats, 
             aes(xintercept = danceability, color = playlist),
             linetype = "dashed") +
  
  geom_text(data = toptracks_stats,
    aes(x = danceability+0.07,
        y = 1,
        label = "mean")
  ) +
  scale_x_continuous(breaks=seq(0.1,1,0.2)) +
  facet_grid(category~year) +
  
  labs(x = "Danceability", y = "Density") +
  theme_mine +
  theme(
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    panel.grid.major.y = element_blank(),
    panel.grid.minor.y = element_blank(),
    panel.border = element_blank(),
    legend.position = "none"
  )
)
```

- Danceability: My taste in music has remained somewhat constant, with the bumps of My Top Tracks of 2019 and My Top Tracks of 2020 both at around 0.75, though the overall distribution is more spread out in 2020 and the mean has slightly decreased. Unlike the other plots, this plot shows that, with respect to danceability, playlists are more similar when grouping by year than they are when grouping by category (personal versus NL). Not only do the shapes look more similar, the mean dancibilities seem to follow the same trend as well; the mean dancibility was slightly lower in 2020 than in 2019. This could be explained by the fact that, due to social distancing measures, there were less occasions to dance. As a result, artists also made less music *to dance to*.

#### Mode

```{r mode barplot}
ggplotly(ggplot(
  toptracks50,
  aes(
    x = year,
    fill = mode_name,
    alpha = 0.95
    )
  ) +
  geom_bar(position = "stack") +
  
  facet_wrap(~category) +
  labs(x = "", y = "Number of tracks") +
  theme_mine +
  theme(panel.grid.major.x = element_blank())
)
```

My Top Tracks playlists clearly count more minor modes (64%) than the NL Top Tracks playlists (49%). Also, there is a slight increase in minor tracks in 2020 as opposed to 2019.




```{r gram setup}
# Sober: 7iHAue5izVmII1Z6Q1xy7B
# Sweetie Odo: 2UAl2nzSixQviGw0XJvJgY
sweetie <-
  get_tidy_audio_analysis("2UAl2nzSixQviGw0XJvJgY") %>%  # Change URI.
  compmus_align(bars, segments) %>%                      # Change `bars`
  select(bars) %>%                                       #   in all three
  unnest(bars) %>%                                       #   of these lines.
  mutate(
    pitches =
      map(segments,
        compmus_summarise, pitches,
        method = "mean", norm = "euclidean"              # Change summary & norm.
      )
  ) %>%
  mutate(
    timbre =
      map(segments,
        compmus_summarise, timbre,
        method = "rms", norm = "euclidean"               # Change summary & norm.
      )
  )
sweetie_sec <-
  get_tidy_audio_analysis("2UAl2nzSixQviGw0XJvJgY") %>%  # Change URI.
  compmus_align(sections, segments) %>%                      # Change `bars`
  select(sections) %>%                                       #   in all three
  unnest(sections) %>%                                       #   of these lines.
  mutate(
    pitches =
      map(segments,
        compmus_summarise, pitches,
        method = "mean", norm = "euclidean"              # Change summary & norm.
      )
  ) %>%
  mutate(
    timbre =
      map(segments,
        compmus_summarise, timbre,
        method = "rms", norm = "euclidean"               # Change summary & norm.
      )
  )
```

### Repetitive chord progressions and vocal 'blocks'
```{r chromagrams bars and sections}
bind_rows(
  sweetie %>% 
    compmus_gather_chroma() %>% 
    mutate(type = "Bars"),
  sweetie_sec %>% 
    compmus_gather_chroma() %>% 
    mutate(type = "Sections")
) %>%
  mutate() %>%
  ggplot(
    aes(
      x = start + duration / 2,
      width = duration,
      y = pitch_class,
      fill = value
    )
  ) +
  geom_tile() +
  scale_x_continuous(breaks=seq(0,155,30)) +
  scale_fill_viridis_c(guide = "none", option = "inferno") +
  facet_wrap(~type) +
  labs(x = "Time (s)", y = NULL, fill = "Magnitude") +
  theme_mine +
  theme(
    panel.grid.major.x = element_blank(),
    panel.grid.major.y = element_blank(),
    panel.border = element_blank()
    )
```

***
#### Chromagrams per bar and per section
###### "Sweetie Odo" by Juls featuring Sway Clarke
This song was a typical Top Track of mine in 2020 (see song info). In the bars chromagram, you can clearly see the repetitive chord progression throughout the song -- the skips from C to A to G. The sections chromagram clearly shows bright 'blocks' at D and C. The D-blocks represent the chorus vocals and the C-block represents the vocals in the bridge. The first few blocks at G, F and D represent the intro.

##### Song info
Under construction
| Feature        | Average                            | "Sweetie Odo" |
|----------------|------------------------------------|---------------|
| Key            |`r mode(my2020$key_name)`           | G Minor
<!-- | Length         |`r mean(my2020$track.duration_ms)`  | 2:35 -->
| BPM            |`r mean(my2020$tempo)`               | 100
| Time Signature |`r median(my2020$time_signature)`   | 4/4



### Different sounds in different sections
```{r cepstograms bars and sections}
bind_rows(
  sweetie %>% 
    compmus_gather_timbre() %>% 
    mutate(type = "Bars"),
  sweetie_sec %>% 
    compmus_gather_timbre() %>% 
    mutate(type = "Sections")
) %>%
  mutate() %>%
  ggplot(
    aes(
      x = start + duration / 2,
      width = duration,
      y = basis,
      fill = value
    )
  ) +
  geom_tile() +
  scale_x_continuous(breaks=seq(0,155,30)) +
  scale_fill_viridis_c(guide = "none", option = "inferno") +
  facet_wrap(~type) +
  labs(x = "Time (s)", y = NULL, fill = "Magnitude") +
  theme_mine +
  theme(
    panel.grid.major.x = element_blank(),
    panel.grid.major.y = element_blank(),
    panel.border = element_blank()
  )
```

***
#### Cepstograms per bar and per section
###### "Sweetie Odo" by Juls featuring Sway Clarke
This song was a typical Top Track of mine in 2020 (see song info). Both cepstograms clearly show the intro and outro in c03. The verses are also brighter in c03. The chorus sections, however, light up in c05. I wonder what this means. The second chorus also lights up in c02, but the first chorus not so much.

##### Song info
Under construction




### Self-similarity matrices
```{r self-similarity matrices}
bind_rows(
  sweetie %>%
    compmus_self_similarity(pitches, "aitchison") %>%
    mutate(d = d / max(d), type = "Chroma"),
  sweetie %>%
    compmus_self_similarity(timbre, "euclidean") %>%
    mutate(d = d / max(d), type = "Timbre")
) %>%
  mutate() %>%
  ggplot(
    aes(
      x = xstart + xduration / 2,
      width = xduration,
      y = ystart + yduration / 2,
      height = yduration,
      fill = d
    )
  ) +
  scale_x_continuous(breaks=seq(0,155,30)) +
  scale_y_continuous(breaks=seq(0,155,30)) +
  geom_tile() +
  coord_fixed() +
  facet_wrap(~type) +
  scale_fill_viridis_c(guide = "none", option = "inferno") +
  labs(x = "", y = "") +
  theme_mine +
  theme(panel.border = element_blank())
```

***
#### Self-similarity matrices for chroma and timbre
###### "Sweetie Odo" by Juls featuring Sway Clarke
The chroma matrix clearly shows the intro, verses (light strips), choruses (dark squares) and outro. The timbre matrix shows the outro even more clearly. Interestingly, the chroma of the outro resembles the verse's chroma. The dark square at the bottom-left corner of the timbre matrix shows the percussion coming in. In general, the clear timbre changes can be ascribed to changes or short pauses in the percussion, even the slight changes just before 60 and 120 seconds represent a short percussion break of about a bar.



### The key visualization

```{r key histogram}
ggplotly(
  ggplot(
    toptracks50, aes(
      x = key_name,
      fill = mode_name,
      alpha = 0.95
      )
    ) +
  geom_histogram(
    stat = "count", 
    position = "stack"         # or "dodge" or "fill"
    ) +
  facet_wrap(~year, ncol = 1) +
  labs(
    x = "Key",
    y = "Number of tracks"
  ) +
  theme_mine +
  theme(panel.grid.major.x = element_blank())
)
```

***
I think there is not much interesting to be said about the distribution of the keys in my corpus -- maybe because my corpus is too small (200 tracks in total). When plotting different variables against each other, there was no plot that really stood out.

The plot on the left shows the key distribution of 2019 versus 2020, taking the two modalities into account. The following changes can be seen over time:

- decrease in A minor;

- increase in C major;

- overall decrease in C#;

- increase in F# minor, partly at the 'expense' of F# major;

- big increase in G# major;

- overall low presence of A#, D, D# and E;

- absence of D minor and near-absence of D# major



### Achordingly, repetition is key

```{r chord and key templates}
circshift <- function(v, n) {
  if (n == 0) v else c(tail(v, n), head(v, -n))
}

#      C     C#    D     Eb    E     F     F#    G     Ab    A     Bb    B
major_chord <-
  c(   1,    0,    0,    0,    1,    0,    0,    1,    0,    0,    0,    0)
minor_chord <-
  c(   1,    0,    0,    1,    0,    0,    0,    1,    0,    0,    0,    0)
seventh_chord <-
  c(   1,    0,    0,    0,    1,    0,    0,    1,    0,    0,    1,    0)

major_key <-
  c(6.35, 2.23, 3.48, 2.33, 4.38, 4.09, 2.52, 5.19, 2.39, 3.66, 2.29, 2.88)
minor_key <-
  c(6.33, 2.68, 3.52, 5.38, 2.60, 3.53, 2.54, 4.75, 3.98, 2.69, 3.34, 3.17)

chord_templates <-
  tribble(
    ~name, ~template,
    "Gb:7", circshift(seventh_chord, 6),
    "Gb:maj", circshift(major_chord, 6),
    "Bb:min", circshift(minor_chord, 10),
    "Db:maj", circshift(major_chord, 1),
    "F:min", circshift(minor_chord, 5),
    "Ab:7", circshift(seventh_chord, 8),
    "Ab:maj", circshift(major_chord, 8),
    "C:min", circshift(minor_chord, 0),
    "Eb:7", circshift(seventh_chord, 3),
    "Eb:maj", circshift(major_chord, 3),
    "G:min", circshift(minor_chord, 7),
    "Bb:7", circshift(seventh_chord, 10),
    "Bb:maj", circshift(major_chord, 10),
    "D:min", circshift(minor_chord, 2),
    "F:7", circshift(seventh_chord, 5),
    "F:maj", circshift(major_chord, 5),
    "A:min", circshift(minor_chord, 9),
    "C:7", circshift(seventh_chord, 0),
    "C:maj", circshift(major_chord, 0),
    "E:min", circshift(minor_chord, 4),
    "G:7", circshift(seventh_chord, 7),
    "G:maj", circshift(major_chord, 7),
    "B:min", circshift(minor_chord, 11),
    "D:7", circshift(seventh_chord, 2),
    "D:maj", circshift(major_chord, 2),
    "F#:min", circshift(minor_chord, 6),
    "A:7", circshift(seventh_chord, 9),
    "A:maj", circshift(major_chord, 9),
    "C#:min", circshift(minor_chord, 1),
    "E:7", circshift(seventh_chord, 4),
    "E:maj", circshift(major_chord, 4),
    "G#:min", circshift(minor_chord, 8),
    "B:7", circshift(seventh_chord, 11),
    "B:maj", circshift(major_chord, 11),
    "D#:min", circshift(minor_chord, 3)
  )

key_templates <-
  tribble(
    ~name, ~template,
    "Gb:maj", circshift(major_key, 6),
    "Bb:min", circshift(minor_key, 10),
    "Db:maj", circshift(major_key, 1),
    "F:min", circshift(minor_key, 5),
    "Ab:maj", circshift(major_key, 8),
    "C:min", circshift(minor_key, 0),
    "Eb:maj", circshift(major_key, 3),
    "G:min", circshift(minor_key, 7),
    "Bb:maj", circshift(major_key, 10),
    "D:min", circshift(minor_key, 2),
    "F:maj", circshift(major_key, 5),
    "A:min", circshift(minor_key, 9),
    "C:maj", circshift(major_key, 0),
    "E:min", circshift(minor_key, 4),
    "G:maj", circshift(major_key, 7),
    "B:min", circshift(minor_key, 11),
    "D:maj", circshift(major_key, 2),
    "F#:min", circshift(minor_key, 6),
    "A:maj", circshift(major_key, 9),
    "C#:min", circshift(minor_key, 1),
    "E:maj", circshift(major_key, 4),
    "G#:min", circshift(minor_key, 8),
    "B:maj", circshift(major_key, 11),
    "D#:min", circshift(minor_key, 3)
  )
```

```{r chordogram setup}
# 7MkcTLPvF3EiarKLYpX4zz
# 0URAjyKMW6cGfW6oFMTh6k
cash <-
  get_tidy_audio_analysis("0URAjyKMW6cGfW6oFMTh6k") %>%
  compmus_align(bars, segments) %>%
  select(bars) %>%
  unnest(bars) %>%
  mutate(
    pitches =
      map(segments,
        compmus_summarise, pitches,
        method = "mean", norm = "manhattan"
      )
  )

loop_niet_weg <-
  get_tidy_audio_analysis("7fmExiQZjHLyDv5SC1EhDg") %>%
  compmus_align(bars, segments) %>%
  select(bars) %>%
  unnest(bars) %>%
  mutate(
    pitches =
      map(segments,
        compmus_summarise, pitches,
        method = "mean", norm = "manhattan"
      )
  )
```

```{r chordogram}
cash %>% 
  compmus_match_pitch_template(
    chord_templates,         # Change to chord_templates if descired
    method = "euclidean",    # Try different distance metrics
    norm = "manhattan"       # Try different norms
  ) %>%
  ggplot(
    aes(x = start + duration / 2, width = duration, y = name, fill = d)
  ) +
  geom_tile() +
  scale_x_continuous(breaks=seq(0,120,15)) +
  scale_fill_viridis_c(guide = "none", option = "inferno") +
  theme_mine +
  theme(rect = element_blank(), line = element_blank()) +
  labs(x = "Time (s)", y = "", title = "Cash - Sarita Lorena")

loop_niet_weg %>% 
  compmus_match_pitch_template(
    chord_templates,         # Change to chord_templates if descired
    method = "euclidean",    # Try different distance metrics
    norm = "manhattan"       # Try different norms
  ) %>%
  ggplot(
    aes(x = start + duration / 2, width = duration, y = name, fill = d)
  ) +
  geom_tile() +
  scale_x_continuous(breaks=seq(0,200,15)) +
  scale_fill_viridis_c(guide = "none", option = "inferno") +
  theme_mine +
  theme(rect = element_blank(), line = element_blank()) +
  labs(x = "Time (s)", y = "", title = "Loop niet weg - Kris Kross Amsterdam")
```

***
Both songs have a very tropical vibe. It's interesting to see that, assuming the chordogram is correct, both songs seem to use the same few chords throughout the whole song. Whereas "Cash" seems to hold the same chord for a few bars, "Loop niet weg" alternates between chords and then repeats that pattern.




### Covid shows no tempo trend

```{r tempo density 2}
ggplotly(ggplot(
  toptracks,
  aes(x = tempo,
      color = playlist,
      fill = playlist)) +
  geom_density(alpha = 0.3) +
  geom_vline(aes(xintercept = mean(tempo)), 
             alpha = 0.5) +
  geom_vline(data = toptracks_stats, 
             aes(xintercept = tempo, color = playlist),
             linetype = "dashed") +
    
  geom_text(data = toptracks_stats,
    aes(x = 130,
        y = 0.022,
        label = "mean")
  ) +
    
  scale_x_continuous(breaks=seq(20,220,40)) +
  facet_grid(category~year) +
    
  labs(x = "Tempo (bpm)", y = "Density") +
  theme_mine +
  theme(
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    panel.grid.major.y = element_blank(),
    panel.grid.minor.y = element_blank(),
    panel.border = element_blank(),
    legend.position = "none"
  )
)
```

***

Unfortunately, my laptop cannot handle tempograms... Instead, I have made a density plot to compare the tempi in different playlists of my corpus.

The tempo distribution in 2019 was pretty much the same in both categories, both peaking at 100 bpm. The peak tempo of My Top Tracks of 2020 has shifted upwards to 105 bpm. The NL Top Tracks of 2020 is totally different form the rest, with no real peaks, and more spread out to lower (90) and higher (120) bpm's. The reference lines for the means clearly show that there was a decrease in tempo between the NL Top Tracks of 2019 and 2020.




<!-- Data visualization: -->
<!-- - https://rkabacoff.github.io/datavis/Time.html#dummbbell-charts -->
<!-- - spider chart: https://www.r-graph-gallery.com/spider-or-radar-chart.html -->
<!-- - circular barplot: https://www.r-graph-gallery.com/circular-barplot.html -->
<!-- http://www.sthda.com/english/wiki/ggplot2-scatter-plots-quick-start-guide-r-software-and-data-visualization -->